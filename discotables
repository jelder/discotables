#!/usr/bin/perl
use strict;
use warnings;

use Getopt::Long;
use IO::Socket::Multicast;
use Crypt::CBC;
use File::Basename;
use English '-no_match_vars';
use Sys::Syslog qw( :standard :macros setlogsock );
use Data::Dumper;

$PROGRAM_NAME = basename $PROGRAM_NAME;
openlog $PROGRAM_NAME, "ndelay,console,nowaitpid", LOG_DAEMON or die $!;
setlogsock 'unix'; # Required on OpenBSD

my $key = '';
my @tables = ();
my $announce = '239.0.0.1';
my $port = '49153';
my $skew = 10;
my $age = 10;
my $debug = 0;

GetOptions(
    'k|key=s' => \$key,
    't|tables=s' => \@tables,
    'age=s' => \$age,
    'announce=s' => \$announce,
    'port=s' => \$port,
    'debug!' => \$debug,
) or die $!;

die "--tables is required" unless @tables;
die "--key is required" unless $key; 

# @tables is a whitelist of tables we allow to be updated via this mechanism.
@tables = split(/,/,join(',',@tables));

# Don't show key in process title.
$PROGRAM_NAME .= " $announce:$port " . join(' ', @tables);

# %discovered is our main data structure.
# Table << IP < Time
my %discovered;

sub _log ($$) {
    my ($pri,$msg) = @_;
    syslog($pri,$msg);
    print STDERR $msg,"\n" if $debug;
}

sub refresh_tables () {
    for my $table (keys %discovered) {
        my @ip;
        for my $ip (keys %{ $discovered{$table} } ) {
            if ($discovered{$table}->{$ip} >= time - $age) {
                push @ip, $ip;
            } else {
                delete $discovered{$table}->{$ip};
            }
        }

        # Always check your assumptions: relayd's tables aren't modifiable through pfclt, and realyctl is weak in this regard. Working on a new design using templates and include statements that will cover both relayd and nginx.
    
        # Log the appopriate pfctl command, then run it.
        _log(LOG_INFO, "table <$table> { " . join(' ',@ip) . ' }');
        my @command = qq(pfctl -t $table -T replace @ip);
        system(@command);

        # Delete the table record if @ip is empty so next iteration will be a no-op. 
        delete $discovered{$table} unless @ip;
    }
    alarm $age;
}

# Set up our cipher
my $cipher = Crypt::CBC->new(
    -key    => $key, 
    -cipher => 'Blowfish'
);

# Set up our multicast listener
my $socket = IO::Socket::Multicast->new(
    LocalPort => $port,
    ReuseAddr => 1,
) or die $!;
$socket->mcast_add($announce);

# Wake up every $age seconds to refresh the tables.
local $SIG{ALRM} = \&refresh_tables;
alarm $age;

while (1) {
    # Grab a frame from the wire
    my $frame;
    next unless $socket->recv($frame,1024);
    my $source = join('.',unpack( "C4", $socket->peeraddr));
    print length($frame) . " from $source\n";

    # Decrypt using pre-shared key
    eval {
        $frame = $cipher->decrypt($frame);
        # Protocol is plain text, so use that to detect failed decryption.
        die "incorrect key\n" unless
            $frame =~ /^[ .0-9a-z_-]+$/io;
    };
    if ($@) {
        # Decrypt failed, log an error with the source IP.
        _log(LOG_ERR, "$source: $@");
        next;
    }

    # Maybe I should use a real serializer here, but this works.
    my ($time_sent, $table, $server)
        = split(' ', $frame, 3);

    # Sanity checks on table names.
    ($table) = ($table =~ /([a-z0-9_-]+)/i);
    unless (grep { $_ eq $table} @tables) {
        _log(LOG_ERR, "$source: $table is not allowed");
        next;
    }
    
    # TODO: $server sanity checking. 

    # Timestamp outside of allowed skew indicates replay attack 
    # or broken client. 
    if ($time_sent - $skew >= time &&
        $time_sent + $skew <= time ){
        _log(LOG_ERR, "$source: forgery or configuration problem");
        next;
    }

    $discovered{$table}->{$server} = time; 
}

