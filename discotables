#!/usr/bin/perl
use strict;
use warnings;

use Getopt::Long;
use IO::Socket::Multicast;
use IO::Select;
use IO::Handle;
use Crypt::CBC;
use File::Basename;
use English '-no_match_vars';
use Sys::Syslog qw( :standard :macros setlogsock );
use Data::Dumper;

$PROGRAM_NAME = basename $PROGRAM_NAME;
openlog $PROGRAM_NAME, "ndelay,console,nowaitpid", LOG_DAEMON or die $!;
setlogsock 'unix'; # Required on OpenBSD

# Set up command line parameters.
my $key = '';
my @tables = ();
my $announce = '239.0.0.1';
my $port = '49153';
my $skew = 10;
my $age = 10;
my $debug = 0;

my @connectors = (
    'nginx_fair',
    'relayd',
);

GetOptions(
    'k|key=s' => \$key,
    't|tables=s' => \@tables,
    'age=s' => \$age,
    'announce=s' => \$announce,
    'port=s' => \$port,
    'debug!' => \$debug,
) or die $!;

die "--tables is required" unless @tables;
die "--key is required" unless $key; 

# @tables is a whitelist of tables we allow to be updated via this mechanism.
@tables = split(/,/,join(',',@tables));

# Don't show key in process title.
$PROGRAM_NAME .= " $announce:$port " . join(' ', @tables);

# Try to log elegantly.
sub _log ($$) {
    my ($pri,$msg) = @_;
    syslog($pri,$msg);
    print STDERR $msg,"\n" if $debug;
}

# render_* actually handle writing the config chunks 
my $disclaimer = <<END;
#
# This file is automatically generated by DiscoTables.
# Do not edit. Your changes will be lost. 
#

END
$disclaimer = '' if $debug;

sub render_nginx_fair (%) {
    my %disco = @_;
    my $conf = '';
    for my $table (keys %disco) {
        $conf .= "upstream $table {\n";
        $conf .= "\t$_;\n" for keys %{ $disco{$table} };
        $conf .= "\tfair;\n}\n";
    }
    return $disclaimer.$conf;
}

sub render_relayd (%) {
    my %disco = @_;
    my $conf = '';
    for my $table (keys %disco) {
        $conf .= "table <$table> {\n";
        $conf .= "\t$_\n" for keys %{ $disco{$table} };
        $conf .= "}\n";
    }
    return $disclaimer.$conf;
}

# %disco is our main data structure.
my %disco;

# We will compare the current state of %disco to the previous so daemons are only reload when necessary.
my %disco_save; 

sub refresh_tables () {
    my $need_reload = 0;
    for my $table (keys %disco) {
        my @hosts;
        for my $host (keys %{ $disco{$table} } ) {
            # Schedule a reload if this host wasn't there last time.
            $need_reload++ unless exists($disco_save{$table}->{$host});
            if ($disco{$table}->{$host} >= time - $age) {
                push @hosts, $host;
            } else {
                delete $disco{$table}->{$host};
                # Schedule a reload since a known host is now missing.
                $need_reload++;
            }
        }

        # Delete the table record if @hosts is empty so next iteration will be a no-op. 
        delete $disco{$table} unless @hosts;
    }
    if ($need_reload) {
        print render_nginx_fair(%disco),render_relayd(%disco);
    }
    %disco_save = %disco;
    alarm $age;
}

sub hexdump (@) {
    for (@_) {
        s/(.)/sprintf("%x",ord($1))/eg;
        print;
    }
}

# Fork and let the child handle network IO. Parent process reads from a pipe and periodically updates load balancer config files. 

pipe(READ, WRITE) or die $!;
WRITE->autoflush(1);

if (fork) {
    close WRITE;

    # Wake up every $age seconds to refresh the tables.
    local $SIG{ALRM} = \&refresh_tables;
    #local $SIG{ALRM} = sub { print STDERR Dumper \%disco; alarm $age };
    alarm $age;

    # Set up our cipher
    my $cipher = Crypt::CBC->new(
        -key    => $key, 
        -cipher => 'Blowfish'
    );

    while (1) {
        my $frame;
        next unless READ->sysread($frame, 1024);

        # Data received from child: two bytes for time, four for source, rest is raw packet.
        my $time_received = unpack('L',substr($frame,0,4,''));
        my $source = join('.',unpack('C4',substr($frame,0,4,'')));

        # Decrypt using pre-shared key
        eval {
            $frame = $cipher->decrypt($frame);
            # Protocol is plain text, so use that to detect failed decryption.
            die "incorrect key\n" unless
                $frame =~ /^[ .0-9a-z_-]+$/io;
        };
        if ($@) {
            # Decrypt failed, log an error with the source IP.
            _log(LOG_ERR, "$source: $@");
            next;
        }

        # Maybe I should use a real serializer here, but this works.
        my ($time_sent, $table, $host)
            = split(' ', $frame, 3);

        # Sanity checks on table names.
        ($table) = ($table =~ /([a-z0-9_-]+)/i);
        unless (grep { $_ eq $table} @tables) {
            _log(LOG_ERR, "$source: $table is not allowed");
            next;
        }
        
        # TODO: $server sanity checking. 

        # Timestamp outside of allowed skew indicates replay attack 
        # or broken client. 
        if ($time_sent - $skew >= $time_sent &&
            $time_sent + $skew <= $time_sent ){
            _log(LOG_ERR, "$source: forgery or configuration problem");
            next;
        }
        
        # Save tuple of table, host and time for later processing by update_tables.
        $disco{$table}->{$host} = $time_sent;
    }
} else {
    # The child just grabs frame off of the network and sends them up to the parent for processing. The source and time are also sent (packed) for checking.

    close READ;

    # Set up our multicast listener
    my $socket = IO::Socket::Multicast->new(
        LocalPort => $port,
        ReuseAddr => 1,
    ) or die $!;
    $socket->mcast_add($announce);

    while (1) {
        my $buffer;
        next unless $socket->recv($buffer,1024);
        WRITE->syswrite(pack('L', time) . $socket->peeraddr . $buffer);
    }
}

