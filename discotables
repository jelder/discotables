#!/usr/bin/perl
use strict;
use warnings;

use Getopt::Long;
use IO::Socket::Multicast;
use Crypt::CBC;
use File::Basename;
use English '-no_match_vars';
use Sys::Syslog qw( :standard :macros setlogsock );

openlog basename $0, "ndelay,console,nowaitpid", LOG_DAEMON or die $!;
setlogsock 'unix'; # Required on OpenBSD

my $key = '';
my $interval = 1;
my $table = '';
my $announce = '239.0.0.1';
my $port = '49153';
my $skew = 10;
my $age = 1;

GetOptions(
    'key=s' => \$key,
    'interval=n' => \$interval,
    'table=s' => \$table,
    'announce=s' => \$announce
) or die $!;

my %discovered;

sub refresh_tables () {
    for my $table (keys %discovered) {
        my @clients;
        for my $client (keys %{ $discovered{$table} } ) {
            if ($discovered{$table}->{$client} >= time - $age) {
                push @clients, $client;
            } else {
                delete $discovered{$table}->{$client};
            }
        }
        syslog(LOG_INFO, "table <$table> { " . join(' ',@clients) . ' }');
        my @command = qq(pfctl -t $table -T replace @clients);
        system(@command);
        delete $discovered{$table} unless @clients;
    }
    alarm $age;
}

my $cipher = Crypt::CBC->new(
    -key    => $key, 
    -cipher => 'Blowfish'
);

my $socket = IO::Socket::Multicast->new(
    LocalPort => $port,
    ReuseAddr => 1,
) or die $!;
$socket->mcast_add($announce);

# Wake up every $age seconds to refresh the tables.
local $SIG{ALRM} = \&refresh_tables;
alarm $age;

while (1) {
    # Grab a frame from the wire
    my $frame;
    next unless $socket->recv($frame,1024);
    next unless $frame =~ /^Salted__/;

    # Record the receipt time and client IP.
    my $time_received = time;
    my $client = join('.',unpack( "C4", $socket->peeraddr));

    # Decrypt using pre-shared key
    eval {
        $frame = $cipher->decrypt($frame);
        die "incorrect key\n" unless
            $frame =~ /^[ 0-9a-z_-]+$/io;
    };
    if ($@) {
        print "$frame $@";
        syslog(LOG_ERR, "$client: $@");
        next;
    }

    # Frame consists of packed:
    #  protocol version  
    #  timestamp
    #  table name
    my ($timestamp, $table)
        = split(' ',$frame,2);
    ($table) = ($table =~ /([a-z0-9_-]+)/i);

    # Timestamp outside of allowed skew indicates replay attack 
    # or broken client. You're running NTP anyway, right?
    if ($timestamp - $skew >= $time_received &&
        $timestamp + $skew <= $time_received ){
        syslog(LOG_ERR, "$client: forgery or configuration problem");
        next;
    }

    $discovered{$table}->{$client} = $time_received; 
}

