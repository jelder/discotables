#!/usr/bin/perl
use strict;
use warnings;

use Getopt::Long;
use IO::Socket::Multicast;
use Crypt::CBC;
use File::Basename;
use English '-no_match_vars';
use Sys::Syslog qw( :standard :macros setlogsock );

$|++;

openlog basename $0, "ndelay,nowaitpid", LOG_DAEMON or die $!;
setlogsock 'unix'; # Required on OpenBSD

my $key = 'Mu9peiph';
my $interval = 1;
my $table = 'solr-wiffiti';
my $announce = '239.0.0.1';
my $port = '1969';
my $skew = 10;
my $age = 3;

GetOptions(
    'key=s' => \$key,
    'interval=n' => \$interval,
    'table=s' => \$table,
    'announce=s' => \$announce
) or die $!;

my %discovered;

sub refresh_tables () {
    for my $table (keys %discovered) {
        my @clients;
        for my $client (keys %{ $discovered{$table} } ) {
            if ($discovered{$table}->{$client} >= time - $age) {
                push @clients, $client;
            } else {
                delete $discovered{$table}->{$client};
            }
        }
        my @command = qq(pfctl -t $table -T replace @clients);
        system(@command);
    }
    alarm $age;
}

my $cipher = Crypt::CBC->new(
    -key    => $key, 
    -cipher => 'Blowfish'
);

my $socket = IO::Socket::Multicast->new(
    LocalPort => $port,
);
$socket->mcast_loopback(0);
$socket->mcast_add($announce);

# Wake up every $age seconds to refresh the tables.
local $SIG{ALRM} = \&refresh_tables;
alarm $age;

while (1) {
    # Grab a frame from the wire and record the receipt time.
    my $frame;
    $socket->recv($frame,1024);
    next unless $frame =~ /^Salted__/;
    my $time_received = time;

    # Decrypt using pre-shared key
    eval { $frame = $cipher->decrypt($frame) };
    if ($@) {
        warn $@;
        next;
    }

    # The frame is made up of time sent, table name, and client.
    my ($timestamp,$table,$client) = split(pack('c',0),$frame) or next;
    $timestamp = unpack('L',$timestamp);
    $client = join('.',unpack( "C4", $client)); 

    # Timestamp outside of allowed skew indicates replay attack 
    # or broken client. You're running NTP anyway, right?
    if ($timestamp - $skew >= $time_received &&
        $timestamp + $skew <= $time_received ){
        syslog(LOG_ERR, "$client: forgery or configuration problem");
        next;
    }
    $discovered{$table}->{$client} = $timestamp;
}

