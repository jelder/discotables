#!/usr/bin/perl
# DiscoTables means control of load balancer tables via multicast discovery. 
# GPL Jacob Elder <jacob.elder@gmail.com> 02009-04-26
use strict;
use warnings;

use Getopt::Long qw(:config pass_through);
use Switch 'Perl6';
use IO::Socket::Multicast;
use IO::Handle;
use Crypt::CBC;
use File::Basename;
use English '-no_match_vars';
use Sys::Syslog qw( :standard :macros setlogsock );
use Data::Dumper;

$Data::Dumper::Terse=1;
$Data::Dumper::Indent=1;
$Data::Dumper::Sortkeys=1;

# Storable is great for rapid prototyping, but not portable enough to allow for wide adoption.  
# 1.0 of DiscoTables is probably going to be a plain text key:value protocol.
use Storable qw(nfreeze freeze thaw);

$PROGRAM_NAME = basename $PROGRAM_NAME;
openlog $PROGRAM_NAME, "ndelay,console,nowaitpid", LOG_DAEMON or die $!;
setlogsock 'unix';

# Set up some defaults. The following are all valid in configuration a file or on the command line.
my %conf = (
    # general options
    iface => '',
    key => 'default',
    mcast_addr => "239.0.0.1",
    mcast_port => 49153,
    check_interval => 1,
    nginx_check => "nginx -t",
    nginx_include => "/var/run/discotables.nginx.conf",
    nginx_reload => "invoke-rc.d nginx reload",
    nginx_upstream_mode => '',
    relay_check => "relayd -n",
    relay_include => "/var/run/discotables.relay.conf",
    relay_reload => "relayctl reload",
    
    # load balancer agent options
    allow_extra => 1,
    allow_port => 1,
    allowed_tables => [],
    allowed_netmasks => [],
    allowed_clock_skew => 10,
    heartbeat_expire => 5,
    handlers => [],

    # host agent options
    host => '',
    table => '',
);

# If we're being passed a configuration file, read in its contents, but then allow further command line arguments to override them.
my $conf_file;
GetOptions(
    'file|f=s' => \$conf_file,
) or die $!;

if (defined($conf_file) && -f $conf_file) {
    %conf = %{ eval slurp($conf_file) }
} 

GetOptions(
    \%conf,
    qw(
        debug|d!
        allowed_tables=s@
        handlers=s@
    ),
    map { $_ .= '=s' } keys %conf
) or die $!;

die "no tables?\n" unless ($conf{allowed_tables});
die "no handlers?\n" unless ($conf{handlers});
die "no key?\n" unless $conf{key}; 

@{ $conf{allowed_tables} } = split(/,/,join(',',@{ $conf{allowed_tables} } ));
@{ $conf{handlers} } = split(/,/,join(',',@{ $conf{handlers} } ));

if ($conf{debug}) {
    print Dumper \%conf;
}

# Configuration is done. Get busy.

# Set a helpful process name.
$PROGRAM_NAME .= " $conf{mcast_addr}:$conf{mcast_port} " . join(' ', @{ $conf{allowed_tables} });

my $disclaimer = <<END;
# This file is automatically generated by DiscoTables.
# Do not edit. Your changes will be lost. 
#

END

# %disco is our main data structure.
my %disco;

# %state exists so we can detect when a host has just become available.
my %state; 

# Fork and let the child handle network IO. Parent process reads from a pipe and periodically invokes the handlers specified in the configuration file. 

pipe(READ, WRITE) or die $!;
WRITE->autoflush(1);

if (fork) {
    close WRITE;

    # Wake up every $age seconds to refresh the tables.
    local $SIG{ALRM} = \&reload;
    alarm $conf{check_interval};

    # Set up our cipher
    my $cipher = Crypt::CBC->new(
        -key    => $conf{key}, 
        -cipher => 'Blowfish'
    );

    while (1) {
        my $buffer;
        next unless READ->sysread($buffer, 1024);
        my ($time_received, $source, $payload) = @{ thaw($buffer) };
        $source = join('.',unpack('C4',$source)); 

        # Decrypt using pre-shared key
        my %heartbeat;
        eval {
            %heartbeat = %{ thaw($cipher->decrypt($payload)) };
        };
        if ($@) {
            # Decrypt failed, log an error with the source IP.
            _log(LOG_ERR, "$source: incorrect key? ($@)");
            next;
        }

        # Timestamp outside of allowed skew indicates replay attack or broken client. 
        if ($heartbeat{timestamp} - $conf{allowed_clock_skew} >= $time_received &&
            $heartbeat{timestamp} + $conf{allowed_clock_skew} <= $time_received ){
            _log(LOG_ERR, "$source: forgery or configuration problem");
            next;
        }

        # Whitelist on table names. 
        unless (grep { $_ eq $heartbeat{table} } @{ $conf{allowed_tables} } ) {
            _log(LOG_ERR, "$source: $heartbeat{table} is not allowed");
            next;
        }

        # TODO: $host sanity checking, something with netmasks perhaps 

        # Port is optional, but make sure it's just a number. 
        if (
            $conf{allow_port} &&
            exists($heartbeat{port}) &&
            $heartbeat{port} =~ /^\d+$/ 
            ) {
            $disco{ $heartbeat{table} }{ $heartbeat{host} }{port} = $heartbeat{port}
        } 

        # Extra fields are optional, but be somewhat strict about what is allowed.
        if (
            $conf{allow_extra} &&
            exists($heartbeat{extra}) &&
            $heartbeat{extra} =~ /^[ \w=_-]+$/
            ) {
            $disco{ $heartbeat{table} }{ $heartbeat{host} }{extra} = $heartbeat{extra}
        } 

        # Lastly, save the timestamp. This is the most important bit, right? 
        $disco{ $heartbeat{table} }{ $heartbeat{host} }{timestamp} = $time_received;
    }
} else {
    # The child just grabs frame off of the network and sends them up to the parent for processing. The source and time are also sent (packed) for checking.

    close READ;

    $PROGRAM_NAME = 'listener: ' . $PROGRAM_NAME;

    # Set up our multicast listener
    my $socket = IO::Socket::Multicast->new(
        LocalPort => $conf{mcast_port},
        ReuseAddr => 1,
    ) or die $!;
    $socket->mcast_if($conf{iface}) if $conf{iface};
    $socket->mcast_add($conf{mcast_addr});

    while (1) {
        my $buffer;
        next unless $socket->recv($buffer,1024);
        WRITE->syswrite(freeze([time, $socket->peeraddr, $buffer]));
    }
}

# Try to log elegantly.
sub _log {
    my ($pri,$msg) = @_;
    chomp $msg;
    syslog($pri,$msg);
    print STDERR $msg,"\n" if $conf{debug};
}

# handler_* interface with lb daemons 
sub handler_monitor { my %disco = @_ ; print Dumper \%disco }

sub handler_nginx {
    my %disco = @_;
    my $conf = '';
    for my $table (keys %disco) {
        $conf .= "upstream $table {\n";

        for my $host (keys %{ $disco{$table} }) {
            my @fields = ("\tserver", $host);

            # Add the port if we have it.
            $fields[1] .= ':' . $disco{$table}{$host}{port}
                if exists $disco{$table}{$host}{port};

            # Add the extra fields if we have them.
            push @fields, $disco{$table}{$host}{extra}
                if exists $disco{$table}{$host}{extra};

            $conf .= join(' ', @fields) . ";\n";
        }

        # We probably need to do something special to fully support ip_hash.
        $conf .= "\t$conf{nginx_upstream_mode};\n"
            if $conf{nginx_upstream_mode};

        $conf .= "}\n";
    }
    open INCLUDE, ">$conf{nginx_include}" or die "$conf{nginx_include}: $!"; 
    print INCLUDE $disclaimer.$conf;
    close INCLUDE;

    # Check the syntax and reload.
    command_wrapper($conf{nginx_check}) && command_wrapper($conf{nginx_reload});
}

sub handler_relay {
    my %disco = @_;
    my $conf = '';
    for my $table (@{ $conf{allowed_tables} }) {
        $conf .= "table <$table> {\n";
        $conf .= "\t$_\n" for keys %{ $disco{$table} };
        $conf .= "}\n";
    }
    open INCLUDE, ">$conf{relay_include}" or die "$conf{relay_include}: $!"; 
    print INCLUDE $disclaimer.$conf;
    close INCLUDE;

    # Check the syntax and reload.
    command_wrapper($conf{relay_check}) && command_wrapper($conf{relay_reload});
}


# Helper function for reading the key from a file.
sub slurp {
    my $file = shift;
    my $data;
    open IN, "<$file" or die "$file: $!";
    { local $/; $data = <IN>; }
    close IN;
    chomp $data; # no trailing newline
    return $data;
}

# This is used for calling the check and reload scripts.
sub command_wrapper {
    my $command = shift;
    my @command = split ' ', $command;
    if (system(@command) == 0) {
        return 1;
    } else {
        my $message;
        if ($? == -1) {
            $message = "failed to execute: $!\n";
        } elsif ($? & 127) {
            $message = sprintf "child died with signal %d, %s coredump\n",
                ($? & 127),  ($? & 128) ? 'with' : 'without';
        } else {
            $message = sprintf "child exited with value %d\n", $? >> 8;
        }
        _log(LOG_ERR, $command);
        _log(LOG_ERR, $message);
        return 0;
    }
}

# This gets called every $check_interval seconds and is pretty much where the magick happens.
sub reload {
    _log(LOG_DEBUG, "in reload()");
    my $need_reload = 0;

    for my $table (keys %disco) {
        my @hosts;
        for my $host (keys %{ $disco{$table} } ) {
            if ($disco{$table}{$host}{timestamp} >= time - $conf{heartbeat_expire}) {
                
                # Schedule a reload, since this host wasn't active last time.
                $need_reload++ unless grep { $_ eq $host} @{ $state{$table} };

                # This host is still good, so add it to the list.
                push @hosts, $host;

            } else {

                # No heartbeat, so delete the host from the table.
                delete $disco{$table}{$host};

                # Schedule a reload since a known host is now missing.
                $need_reload++;
            }
        }

        # Save a record of what we discovered this time.
        $state{$table} = [@hosts];

        # Delete the table record if @hosts is empty so next iteration will be a no-op. 
        delete $disco{$table} unless @hosts;

    }
    if ($need_reload) {
        handler_nginx(%disco) if grep { $_ eq 'nginx' } @{ $conf{handlers} }; 
        handler_relay(%disco) if grep { $_ eq 'relay' } @{ $conf{handlers} }; 
        handler_monitor(%disco) if grep { $_ eq 'monitor' } @{ $conf{handlers} }; 
    }
    alarm $conf{check_interval};
}

