#!/usr/bin/perl
use strict;
use warnings;

use Getopt::Long;
use Switch 'Perl6';
use IO::Socket::Multicast;
use IO::Select;
use IO::Handle;
use Crypt::CBC;
use File::Basename;
use English '-no_match_vars';
use Sys::Syslog qw( :standard :macros setlogsock );
use Data::Dumper;

$PROGRAM_NAME = basename $PROGRAM_NAME;
openlog $PROGRAM_NAME, "ndelay,console,nowaitpid", LOG_DAEMON or die $!;
setlogsock 'unix' if $OSNAME eq 'openbsd';

# Configuration parameters with defaults. When adding new configuration parameters, add it here, even with a null default so the parser won't discard it.
my %conf = (
    announce_addr => "239.0.0.1",
    announce_port => 49153,
    check_interval => 1,
    heartbeat_expire => 10,
    allowed_clock_skew => 10,
    nginx_include => "/var/run/discotables.nginx.conf",
    nginx_check => "nginx -t",
    nginx_reload => "invoke-rc.d nginx reload",
    nginx_port => '80',
    nginx_extra => '',
    relay_include => "/var/run/discotables.relay.conf",
    relay_check => "relayd -n",
    relay_reload => "relayctl reload",
    nginx_upstream_mode => '',
    key => 'default',
);
my (@conf_tables,@conf_netmasks,@conf_handlers);

my $conf_file;
my $debug = 0;

GetOptions(
    'f|c|conf=s' => \$conf_file,
    'd|debug!' => \$debug,
) or die $!;

die "--conf is required\n" unless $conf_file; 

open CONF, $conf_file or die $!;
while (<CONF>) {
    chomp;
    next unless /^(\w+)\s+(.+)/;
    my ($key, $val) = ($1, $2);
    given ($key) {
        when 'keyfile'  { $conf{key} = slurp($val) };
        when 'table'    { push @conf_tables, $val };
        when 'netmask'  { push @conf_netmasks, $val };
        when 'handler'  {
            if (grep { $_ eq $val } qw(nginx relay monitor)) {
                push @conf_handlers, $val;
            } else {
                print "There is no handler called $val (yet).\n";
                exit 75;
            }
        };
        default {
            if (grep { $key eq $_ } keys %conf) {
                $conf{$key} = $val;
            } else {
                print "Not understood: $_\n";
                exit 75;
            }
        }
    }
}
close CONF;

die "no tables?\n" unless @conf_tables;
die "no handlers?\n" unless @conf_handlers;
die "no key?\n" unless $conf{key}; 

if ($debug) {
    print Dumper \%conf;
    print Dumper \@conf_tables;
    print Dumper \@conf_handlers;
}

# Configuration is done. Get busy.

# Set a helpful process name.
$PROGRAM_NAME .= " $conf{announce_addr}:$conf{announce_port} " . join(' ', @conf_tables);

my $disclaimer = <<END;
# This file is automatically generated by DiscoTables.
# Do not edit. Your changes will be lost. 
#

END

# %disco is our main data structure.
my %disco;

# %disco_save exists so we can detect when a host has just become available.
my %disco_save; 

# Fork and let the child handle network IO. Parent process reads from a pipe and periodically updates load balancer config files. 

pipe(READ, WRITE) or die $!;
WRITE->autoflush(1);

if (fork) {
    close WRITE;

    # Wake up every $age seconds to refresh the tables.
    local $SIG{ALRM} = \&reload;
    alarm $conf{check_interval};

    # Set up our cipher
    my $cipher = Crypt::CBC->new(
        -key    => $conf{key}, 
        -cipher => 'Blowfish'
    );

    while (1) {
        my $frame;
        next unless READ->sysread($frame, 1024);

        # Data received from child: four bytes of time, four of source, remainder is raw packet.
        my $time_received = unpack('L',substr($frame,0,4,''));
        my $source = join('.',unpack('C4',substr($frame,0,4,'')));

        #print length($frame) . " bytes from $source\n" if $debug;

        # Decrypt using pre-shared key
        eval {
            $frame = $cipher->decrypt($frame);
            # Protocol is plain text, so use that to detect failed decryption.
            die "incorrect key\n" unless
                $frame =~ /^[ .0-9a-z_-]+$/io;
        };
        if ($@) {
            # Decrypt failed, log an error with the source IP.
            _log(LOG_ERR, "$source: $@");
            next;
        }

        # Maybe I should use a real serializer here, but this works.
        my ($time_sent, $table, $host)
            = split(' ', $frame, 3);

        # Sanity checks on table names.
        ($table) = ($table =~ /([a-z0-9_-]+)/i);
        unless (grep { $_ eq $table} @conf_tables) {
            _log(LOG_ERR, "$source: $table is not allowed");
            next;
        }
        
        # TODO: $host sanity checking, something with netmasks perhaps 

        # Timestamp outside of allowed skew indicates replay attack 
        # or broken client. 
        if ($time_sent - $conf{allowed_clock_skew} >= $time_sent &&
            $time_sent + $conf{allowed_clock_skew} <= $time_sent ){
            _log(LOG_ERR, "$source: forgery or configuration problem");
            next;
        }
        
        # Save tuple of table, host and time for later processing by update_tables.
        $disco{$table}{$host}{timestamp} = $time_sent;
    }
} else {
    # The child just grabs frame off of the network and sends them up to the parent for processing. The source and time are also sent (packed) for checking.

    close READ;

    $PROGRAM_NAME = 'listener: ' . $PROGRAM_NAME;

    # Set up our multicast listener
    my $socket = IO::Socket::Multicast->new(
        LocalPort => $conf{announce_port},
        ReuseAddr => 1,
    ) or die $!;
    $socket->mcast_add($conf{announce_addr});

    while (1) {
        my $buffer;
        next unless $socket->recv($buffer,1024);
        WRITE->syswrite(pack('L', time) . $socket->peeraddr . $buffer);
    }
}

# Try to log elegantly.
sub _log {
    my ($pri,$msg) = @_;
    chomp $msg;
    syslog($pri,$msg);
    print STDERR $msg,"\n" if $debug;
}

# handler_* interface with lb daemons 
sub handler_monitor { my %disco = @_ ; print Dumper \%disco }

sub handler_nginx {
    my %disco = @_;
    my $conf = '';
    my $extra = $conf{nginx_extra} || '';
    my $port = $conf{nginx_port};
    for my $table (keys %disco) {
        # We probably need to do something special to fully support ip_hash.
        $conf .= "upstream $table {\n";
        $conf .= "\tserver $_:$port $extra;\n" for keys %{ $disco{$table} };
        $conf .= "\t$conf{nginx_upstream_mode};\n"
            if $conf{nginx_upstream_mode};
        $conf .= "}\n";
    }
    open INCLUDE, ">$conf{nginx_include}" or die "$conf{nginx_include}: $!"; 
    print INCLUDE $disclaimer.$conf;
    close INCLUDE;

    # Check the syntax and reload.
    command_wrapper($conf{nginx_check}) && command_wrapper($conf{nginx_reload});
}

sub handler_relay {
    my %disco = @_;
    my $conf = '';
    for my $table (@conf_tables) {
        $conf .= "table <$table> {\n";
        $conf .= "\t$_\n" for keys %{ $disco{$table} };
        $conf .= "}\n";
    }
    open INCLUDE, ">$conf{relay_include}" or die "$conf{relay_include}: $!"; 
    print INCLUDE $disclaimer.$conf;
    close INCLUDE;

    # Check the syntax and reload.
    command_wrapper($conf{relay_check}) && command_wrapper($conf{relay_reload});
}


# Helper function for reading the key from a file.
sub slurp {
    my $file = shift;
    my $data;
    open IN, "<$file" or die "$file: $!";
    { local $/; $data = <IN>; }
    close IN;
    chomp $data; # no trailing newline
    return $data;
}

# Leftover from development, might still be useful to have a hex dumper.
sub hexdump {
    for (@_) {
        s/(.)/sprintf("%x",ord($1))/eg;
        print;
    }
}

# This is used for calling the check and reload scripts.
sub command_wrapper {
    my $command = shift;
    my @command = split ' ', $command;
    if (system(@command) == 0) {
        return 1;
    } else {
        my $message;
        if ($? == -1) {
            $message = "failed to execute: $!\n";
        } elsif ($? & 127) {
            $message = sprintf "child died with signal %d, %s coredump\n",
                ($? & 127),  ($? & 128) ? 'with' : 'without';
        } else {
            $message = sprintf "child exited with value %d\n", $? >> 8;
        }
        _log(LOG_ERR, $command);
        _log(LOG_ERR, $message);
        return 0;
    }
}

# This gets called every $check_interval seconds and is pretty much where the magick happens.
sub reload {
    _log(LOG_DEBUG, "in reload()");
    my $need_reload = 0;

    for my $table (keys %disco) {
        my @hosts;
        for my $host (keys %{ $disco{$table} } ) {
            if ($disco{$table}{$host}{timestamp} >= time - $conf{heartbeat_expire}) {
                
                # Schedule a reload, since this host wasn't active last time.
                $need_reload++ unless grep { $_ eq $host} @{ $disco_save{$table} };

                # This host is still good, so add it to the list.
                push @hosts, $host;

            } else {

                # No heartbeat, so delete the host from the table.
                delete $disco{$table}{$host};

                # Schedule a reload since a known host is now missing.
                $need_reload++;
            }
        }

        # Save a record of what we discovered this time.
        $disco_save{$table} = [@hosts];

        # Delete the table record if @hosts is empty so next iteration will be a no-op. 
        delete $disco{$table} unless @hosts;

    }
    if ($need_reload) {
        handler_nginx(%disco) if grep { $_ eq 'nginx' } @conf_handlers; 
        handler_relay(%disco) if grep { $_ eq 'relay' } @conf_handlers; 
        handler_monitor(%disco) if grep { $_ eq 'monitor' } @conf_handlers; 
    }
    alarm $conf{check_interval};
}

