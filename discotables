#!/usr/bin/perl
use strict;
use warnings;

use Getopt::Long;
use IO::Socket::Multicast;
use IO::Select;
use IO::Handle;
use Crypt::CBC;
use File::Basename;
use English '-no_match_vars';
use Sys::Syslog qw( :standard :macros setlogsock );
use Data::Dumper;

$PROGRAM_NAME = basename $PROGRAM_NAME;
openlog $PROGRAM_NAME, "ndelay,console,nowaitpid", LOG_DAEMON or die $!;
setlogsock 'unix'; # Required on OpenBSD

# Set up command line parameters.
my $key = '';
my @tables = ();
my $announce = '239.0.0.1';
my $port = '49153';
my $skew = 10;
my $age = 10;
my $debug = 0;

my @connectors = (
    'nginx_fair',
    'relayd',
);

GetOptions(
    'k|key=s' => \$key,
    't|tables=s' => \@tables,
    'age=s' => \$age,
    'announce=s' => \$announce,
    'port=s' => \$port,
    'debug!' => \$debug,
) or die $!;

die "--tables is required" unless @tables;
die "--key is required" unless $key; 

# @tables is a whitelist of tables we allow to be updated via this mechanism.
@tables = split(/,/,join(',',@tables));

# Don't show key in process title.
$PROGRAM_NAME .= " $announce:$port " . join(' ', @tables);

# Try to log elegantly.
sub _log ($$) {
    my ($pri,$msg) = @_;
    syslog($pri,$msg);
    print STDERR $msg,"\n" if $debug;
}

# render_* actually handle writing the config chunks 
my $disclaimer = <<END;
#
# This file is automatically generated by DiscoTables.
# Do not edit. Your changes will be lost. 
#

END

sub render_nginx_fair ($@) {
    my ($table,@hosts) = @_;
    my $conf = $disclaimer;
    $conf .= "upstream $table {\n";
    $conf .= "\t$_;\n" for @hosts;
    $conf .= "\tfair;\n}\n";
    print $conf;
}

sub render_relayd (@) {
    my ($table,@hosts) = @_;
    my $conf = $disclaimer;
    $conf .= "table <$table> {\n";
    $conf .= "\t$_\n" for @hosts;
    $conf .= "}\n";
    print $conf;
}

# %disco is our main data structure.
my %disco;

sub refresh_tables () {
    print "in refresh_tables\n";
    for my $table (keys %disco) {
        my @hosts;
        for my $host (keys %{ $disco{$table} } ) {
            if ($disco{$table}->{$host} >= time - $age) {
                push @hosts, $host;
            } else {
                delete $disco{$table}->{$host};
            }
        }

        render_nginx_fair($table,@hosts);
        render_relayd($table,@hosts);

        # Delete the table record if @hosts is empty so next iteration will be a no-op. 
        delete $disco{$table} unless @hosts;
    }
    alarm $age;
}

# Fork and let the child handle network IO. Parent process reads from a pipe and periodically updates load balancer config files. 

pipe(READ, WRITE) or die $!;

if (fork) {
    close WRITE;

    # Wake up every $age seconds to refresh the tables.
    local $SIG{ALRM} = \&refresh_tables;
    alarm $age;

    while (<READ>) {
        my ($time, $table, $host)
            = split / /, $_;
        print $_;
        $disco{$table}->{$host} = $time;
    }
} else {
    close READ;
    # Set up our cipher
    my $cipher = Crypt::CBC->new(
        -key    => $key, 
        -cipher => 'Blowfish'
    );

    # Set up our multicast listener
    my $socket = IO::Socket::Multicast->new(
        LocalPort => $port,
        ReuseAddr => 1,
    ) or die $!;
    $socket->mcast_add($announce);

    my $select = new IO::Select( $socket ) 
        or die $!;

    while (my @ready = $select->can_read) {
        for my $fh (@ready) {
            # Grab a frame from the wire
            my $frame;
            next unless $socket->recv($frame,1024);
            my $source = join('.',unpack( "C4", $socket->peeraddr));

            # Decrypt using pre-shared key
            eval {
                $frame = $cipher->decrypt($frame);
                # Protocol is plain text, so use that to detect failed decryption.
                die "incorrect key\n" unless
                    $frame =~ /^[ .0-9a-z_-]+$/io;
            };
            if ($@) {
                # Decrypt failed, log an error with the source IP.
                _log(LOG_ERR, "$source: $@");
                next;
            }

            # Maybe I should use a real serializer here, but this works.
            my ($time_sent, $table, $server)
                = split(' ', $frame, 3);

            # Sanity checks on table names.
            ($table) = ($table =~ /([a-z0-9_-]+)/i);
            unless (grep { $_ eq $table} @tables) {
                _log(LOG_ERR, "$source: $table is not allowed");
                next;
            }
            
            # TODO: $server sanity checking. 

            # Timestamp outside of allowed skew indicates replay attack 
            # or broken client. 
            if ($time_sent - $skew >= time &&
                $time_sent + $skew <= time ){
                _log(LOG_ERR, "$source: forgery or configuration problem");
                next;
            }

            WRITE->printflush(join(' ', time, $table, $server),"\n");
            WRITE->flush;
        }
    }
}

